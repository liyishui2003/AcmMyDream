# 指针

### 寻址变量
在变量前面加上地址运算符(&)来获得变量的地址。printf打印时用"%p"。

### 指针大小
在现代桌面系统中，指针大小与CPU的通用寄存器相同。x86架构拥有32位（4字节）通用寄存器，而x64架构则是64位（8字节）通用寄存器。
因此32位的指针大小为4字节。

### 解引用
解引用运算符(*)是一个一元运算符，它可以访问指针所指的对象，是地址运算符的逆运算。

### 成员指针运算符
成员指针运算符或箭头运算符(->)同时执行两个操作：

❑ 它对指针解引用。

❑ 它访问被指向的对象的成员。
箭头看起来更直观。

### 和数组比起来
指针对对象的位置进行编码，而数组则对连续对象的位置和长度进行编码。只要稍微对数组施加操作，数组就会退化成指针。退化后的数组会失去长度信息，并转换为指向数组第一个元素的指针。
```
int array[]{3,6,9};
int* key_ptr=array;//此时key_ptr指向的是array的第一个元素
```
另外一个退化的例子是：
```
char name[256];
printf("%s",name);//printf格式指定符%s期望C格式字符串——char指针
```
我们会将数组作为两种参数传递(在系统编程中很常见)：

❑ 指向第一个元素的指针。

❑ 数组的长度。

实现这种模式的机制是方括号([​])，方括号对指针的作用就像对数组的作用一样。
```
void out(node* sch,size_t num){
  for(size_t i=0;i<num;i++){
      printf("%s",sch[i].name);//方括号对指针的作用就像对数组的作用一样
  }
}
```
### 指针算术
要获得数组中第n个元素的地址:
- 直接用方括号([​])获取第n个元素，然后使用地址运算符(&)获得地址。
- 当在指针上加减整数时，编译器会使用指针指向的类型的大小计算出正确的字节偏移。例如，在uint64_t指针上加4，会增加32个字节：一个uint64_t占8个字节，所以4个占32个字节。因此

其实括号运算本身就是指针算数。

### void*和std::byte指针
void*:
- 指向的对象类型是不确定的。这种情况下，可以使用空(void)指针void*。后面有需要再强制转化。
- 不能对void*进行解引用和指针算术

byte*:在字节级别与内存进行交互，例如，在文件和内存之间复制原始数据或者加密和压缩等底层操作。

### 特殊值：nullptr与隐式转化
等于nullptr的指针不指向任何东西。
指针具有隐式转换为布尔值的功能。任何不是nullptr的值都会隐式转换为true，而nullptr则会隐式转换为false。
常见的用法是，函数运行失败时返回nullptr。典型的例子是内存分配。

### 引用
引用(reference)是指针的更安全、更方便版本。
- 在类型名后附加&声明符即可声明引用。
- 引用不能被（轻易）设置为空，也不能被重新定位（或重新赋值）​。这里的重新定位指的是：
```
int origin=100;
int& original_ref=original;
int new_value=200;
original_ref=new_value;//此处并不能把original_ref指向new_value
//而是把new_value的值都赋给了origin_ref、origin，最后大家都是200.
```
- 不使用成员指针运算符和解引用运算符，而是将引用完全当作目标类型来使用。

### 指针和引用的对比
指针和引用在很大程度上是可以互换的，但两者各有利弊。
如果有时必须改变引用类型的值，那么必须使用指针。
因为引用不能被重新定位，而且它们一般不应该被赋值为nullptr，所以有些场合并不适合使用引用。

### this指针
常用在方法里，当传入与成员同名的参数时，方法的参数总是会掩盖成员，此时可以用this来消除歧义。

### const 
我们可以在函数和类的定义中使用const来指定变量（通常是引用或指针）​，表示该变量不会被该函数或类修改。
- 将参数标记为const可以防止在函数的作用域内修改它。
- 将方法标记为const表示承诺不会在const方法中修改当前对象的状态。换句话说，这些方法都是只读方法。
```
int get_year()const{
  return year;
}
```
const引用和指针的持有者不能调用非const方法
- const成员变量在初始化后不能被修改。
 
### 成员初始化列表
```
struct Avout{
  const char* name;
  Clock apert;
  Avout(const char* name,long year_of_apert):name{name},apert{year_of_apert}{
     //nothing
  }
}
```
所有的成员初始化都在构造函数之前执行。这有两个好处：

❑ 它在构造函数执行之前确保所有成员的有效性，所以可以让我们专注于初始化逻辑而不是成员错误检查。

❑ 成员只初始化一次。如果在构造函数中重新给成员赋值，可能会产生额外的工作量。


